import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { CreateUserDto, LoginUserResponseDto } from './dto/create-user.dto';
import { User, UserDocument } from './schemas/user.schema';
import * as jwt from 'jsonwebtoken';
import { ConfigService } from '@nestjs/config';
import configuration from 'config/configuration';

/**
 * 1. Fetch user's profile
 * 2. Login a user
 * 3. Generate Token for user
 * 4. Verify Token for user
 * 5. Get all users
 */
@Injectable()
export class UsersService {
  constructor(
    @InjectModel(User.name) private readonly userModel: Model<UserDocument>,
  ) {}

  /**
   *
   * @param createUserDto Object to send user's parameters
   * @returns Login Data to store as cookies on the server side
   * @description Used to either create a new user or login an existing user smartly.
   */
  async login(createUserDto: CreateUserDto): Promise<LoginUserResponseDto> {
    const existingUser = await this.userModel
      .findOne({
        phoneNumber: createUserDto.phoneNumber,
      })
      .lean();
    if (existingUser) {
      const data = {
        token: this.generateToken(existingUser._id.toString()),
        userId: existingUser._id.toString(),
      };
      return data;
    }
    const user = await this.userModel.create({
      name: createUserDto.userName,
      phoneNumber: createUserDto.phoneNumber,
    });
    return {
      token: this.generateToken(user._id),
      userId: user._id,
    };
  }

  /**
   * @description Used to get all users in the database
   * @returns All user's data
   */
  findAll() {
    return this.userModel.find();
  }

  /**
   *
   * @param id User's ID
   * @returns User's data
   */
  async findOne(id: string): Promise<User> {
    const user = await this.userModel.findById(id);
    return user;
  }

  /**
   *
   * @param id User's ID for JWT token generation
   * @returns The token generated by JWT
   */
  generateToken(id) {
    return jwt.sign({ id }, configuration().jwtSecret, {
      expiresIn: configuration().jwtExpiry,
    });
  }

  /**
   *
   * @param token Token to be verified
   * @returns The user ID if the token could be verified or throws an error 'Invalid Token'
   */
  async verifyToken(token: string): Promise<string> {
    const secret = configuration().jwtSecret;
    const decoded: any = jwt.verify(token, secret);
    if (!decoded.id) {
      throw 'Invalid Token';
    }
    return decoded.id;
  }

  /**
   * Find a user with the given phone number
   * @param {string} phoneNumber
   * @returns {User}
   */
  async findByPhoneNumber(phoneNumber: string) {
    return this.userModel.findOne({ phoneNumber });
  }

  async getWallet(token: string) {}

  /** Generate the user's wallet token */
  generateWalletToken(user: User) {
    const id = user._id.toString();
    const l = Number.parseInt((id.length / 2).toString());
    console.log(l);
    return id.split('').slice(l).join('') + id.split('').slice(0, l).join('');
  }

  /** Helper function to get the user from the given token */
  async getUserFromWalletToken(token: string): Promise<User> {
    const l = Number.parseInt((token.length / 2).toString());
    const userId =
      token.split('').slice(l).join('') + token.split('').slice(0, l).join('');
    return this.userModel.findById(userId);
  }

  /** Update the user's wallet address */
  updateWalletAddress(user: User, address: string) {
    return this.userModel.findByIdAndUpdate(user._id, {
      walletAddress: address,
    });
  }

  /** Update the user's address, with the given wallet token */
  async updateWalletWithToken(token: string, address: string) {
    const user = await this.getUserFromWalletToken(token);
    return await this.updateWalletAddress(user, address);
  }
}
