import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { CreateUserDto, LoginUserResponseDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';
import { User, UserDocument } from './schemas/user.schema';
import * as jwt from 'jsonwebtoken';
import { ConfigService } from '@nestjs/config';
import configuration from 'config/configuration';

/**
 * 1. Fetch user's profile
 * 2. Login a user
 * 3. Generate Token for user
 * 4. Verify Token for user
 * 5. Get all users
 */
@Injectable()
export class UsersService {
  constructor(
    @InjectModel(User.name) private readonly userModel: Model<UserDocument>,
  ) {}

  /**
   *
   * @param createUserDto Object to send user's parameters
   * @returns Login Data to store as cookies on the server side
   * @description Used to either create a new user or login an existing user smartly.
   */
  async login(createUserDto: CreateUserDto): Promise<LoginUserResponseDto> {
    const existingUser = await this.userModel
      .findOne({
        phoneNumber: createUserDto.phoneNumber,
      })
      .lean();
    if (existingUser) {
      const data = {
        token: this.generateToken(existingUser._id.toString()),
        userId: existingUser._id.toString(),
      };
      return data;
    }
    const user = await this.userModel.create({
      name: createUserDto.userName,
      phoneNumber: createUserDto.phoneNumber,
    });
    return {
      token: this.generateToken(user._id),
      userId: user._id,
    };
  }

  /**
   * @description Used to get all users in the database
   * @returns All user's data
   */
  findAll() {
    return this.userModel.find();
  }

  /**
   *
   * @param id User's ID
   * @returns User's data
   */
  async findOne(id: string): Promise<User> {
    const user = await this.userModel.findById(id);
    return user;
  }

  /**
   *
   * @param id User's ID for JWT token generation
   * @returns The token generated by JWT
   */
  generateToken(id) {
    return jwt.sign({ id }, configuration().jwtSecret, {
      expiresIn: configuration().jwtExpiry,
    });
  }

  /**
   *
   * @param token Token to be verified
   * @returns The user ID if the token could be verified or throws an error 'Invalid Token'
   */
  async verifyToken(token: string): Promise<string> {
    const secret = configuration().jwtSecret;
    const decoded: any = jwt.verify(token, secret);
    if (!decoded.id) {
      throw 'Invalid Token';
    }
    return decoded.id;
  }
}
